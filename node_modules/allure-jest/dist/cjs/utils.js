"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldHookBeSkipped = exports.last = exports.isTestPresentInTestPlan = exports.getTestPath = exports.getTestId = exports.getTestFullName = void 0;
var _allureJsCommons = require("allure-js-commons");
var _sdk = require("allure-js-commons/sdk");
/**
 * Returns array of names which represents full test hierarchy
 * Omits ROOT_DESCRIBE_BLOCK because it shouldn't be reported
 *
 * @param test Test or describe block
 * @returns
 */
var getTestPath = test => {
  var path = [];
  var currentUnit = test;
  while (currentUnit) {
    if (currentUnit.name) {
      path.unshift(currentUnit.name);
    }
    currentUnit = currentUnit.parent;
  }

  // debugger

  // first element is always ROOT_DESCRIBE_BLOCK, which shouldn't be reported
  return path.slice(1);
};

/**
 * Returns starndartized test name what can be used as test Id
 *
 * @doc https://github.com/jestjs/jest/blob/25a8785584c9d54a05887001ee7f498d489a5441/packages/jest-circus/src/utils.ts#L410
 * @param path Path memebers
 * @returns
 */
exports.getTestPath = getTestPath;
var getTestId = path => path.join(" ");

/**
 * Returns test full name (test hierarchy joined by " > ")
 *
 * @param path Path memebers
 * @returns
 */
exports.getTestId = getTestId;
var getTestFullName = path => path.join(" > ");
exports.getTestFullName = getTestFullName;
var jestHookPattern = /^at jestAdapter/i;
// A slightly different reference should be used to identify jestAdapter's global hook in some older versions of Jest.
var jestHookLegacyPattern = /jest-circus\/build\/legacy-code-todo-rewrite\/jestAdapter.js:\d+:\d+$/;
var shouldHookBeSkipped = hook => {
  var _stack$split;
  // In older versions of Jest the hook's stack is direcrly in asyncError. In newer ones - in asyncError.stack.
  var stackOrError = hook === null || hook === void 0 ? void 0 : hook.asyncError;
  var stack = typeof stackOrError === "string" ? stackOrError : stackOrError === null || stackOrError === void 0 ? void 0 : stackOrError.stack;
  var errorFirstLine = (stack === null || stack === void 0 || (_stack$split = stack.split("\n")) === null || _stack$split === void 0 || (_stack$split = _stack$split[1]) === null || _stack$split === void 0 ? void 0 : _stack$split.trim()) || "";
  return jestHookPattern.test(errorFirstLine) || jestHookLegacyPattern.test(errorFirstLine);
};
exports.shouldHookBeSkipped = shouldHookBeSkipped;
var last = array => array[array.length - 1];
exports.last = last;
var isTestPresentInTestPlan = (testFullName, testPlan) => {
  var {
    labels
  } = (0, _sdk.extractMetadataFromString)(testFullName);
  var allureIdLabel = labels.find(_ref => {
    var {
      name
    } = _ref;
    return name === _allureJsCommons.LabelName.ALLURE_ID;
  });
  return testPlan.tests.some(_ref2 => {
    var {
      id,
      selector = ""
    } = _ref2;
    var idMatched = id ? String(id) === (allureIdLabel === null || allureIdLabel === void 0 ? void 0 : allureIdLabel.value) : false;
    var selectorMatched = selector === testFullName;
    return idMatched || selectorMatched;
  });
};
exports.isTestPresentInTestPlan = isTestPresentInTestPlan;
//# sourceMappingURL=utils.js.map