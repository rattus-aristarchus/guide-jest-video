var _excluded = ["resultsDir"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import os from "node:os";
import { dirname, sep } from "node:path";
import process from "node:process";
import * as allure from "allure-js-commons";
import { LabelName, Stage, Status } from "allure-js-commons";
import { getMessageAndTraceFromError, getStatusFromError } from "allure-js-commons/sdk";
import { FileSystemWriter, MessageWriter, ReporterRuntime, getEnvironmentLabels, getSuiteLabels, parseTestPlan } from "allure-js-commons/sdk/reporter";
import { setGlobalTestRuntime } from "allure-js-commons/sdk/runtime";
import { AllureJestTestRuntime } from "./AllureJestTestRuntime.js";
import { getTestId, getTestPath, isTestPresentInTestPlan, last, shouldHookBeSkipped } from "./utils.js";
var {
  ALLURE_TEST_MODE,
  ALLURE_HOST_NAME,
  ALLURE_THREAD_NAME,
  JEST_WORKER_ID
} = process.env;
var hostname = os.hostname();
var createJestEnvironment = Base => {
  var _Class_brand;
  // @ts-expect-error (ts(2545)) Incorrect assumption about a mixin class: https://github.com/microsoft/TypeScript/issues/37142
  return _Class_brand = /*#__PURE__*/new WeakSet(), class extends Base {
    // config is AllureJestConfig in Jest v28 or greater. In older versions
    // it's AllureJestProjectConfig. See https://github.com/jestjs/jest/pull/12461
    constructor(config, context) {
      super(config, context);
      _classPrivateMethodInitSpec(this, _Class_brand);
      _defineProperty(this, "testPath", void 0);
      _defineProperty(this, "testPlan", void 0);
      _defineProperty(this, "runtime", void 0);
      _defineProperty(this, "runContext", {
        executables: [],
        steps: [],
        scopes: [],
        skippedTestsFullNamesByTestPlan: []
      });
      _defineProperty(this, "handleTestEvent", event => {
        switch (event.name) {
          case "hook_start":
            _assertClassBrand(_Class_brand, this, _handleHookStart).call(this, event.hook);
            break;
          case "hook_success":
            _assertClassBrand(_Class_brand, this, _handleHookPass).call(this, event.hook);
            break;
          case "hook_failure":
            _assertClassBrand(_Class_brand, this, _handleHookFail).call(this, event.hook, event.error);
            break;
          case "run_describe_start":
            _assertClassBrand(_Class_brand, this, _handleSuiteStart).call(this);
            break;
          case "run_describe_finish":
            _assertClassBrand(_Class_brand, this, _handleSuiteEnd).call(this);
            break;
          case "test_start":
            _assertClassBrand(_Class_brand, this, _handleTestStart).call(this, event.test);
            break;
          case "test_done":
            _assertClassBrand(_Class_brand, this, _handleTestDone).call(this);
            break;
          case "test_todo":
            _assertClassBrand(_Class_brand, this, _handleTestTodo).call(this, event.test);
            break;
          case "test_fn_success":
            _assertClassBrand(_Class_brand, this, _handleTestPass).call(this, event.test);
            break;
          case "test_fn_failure":
            _assertClassBrand(_Class_brand, this, _handleTestFail).call(this, event.test);
            break;
          case "test_skip":
            _assertClassBrand(_Class_brand, this, _handleTestSkip).call(this, event.test);
            break;
          case "run_finish":
            _assertClassBrand(_Class_brand, this, _handleRunFinish).call(this);
            break;
          default:
            break;
        }
      });
      var projectConfig = "projectConfig" in config ? config.projectConfig : config;
      var _ref = (projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.testEnvironmentOptions) || {},
        {
          resultsDir = "allure-results"
        } = _ref,
        restConfig = _objectWithoutProperties(_ref, _excluded);
      this.runtime = new ReporterRuntime(_objectSpread(_objectSpread({}, restConfig), {}, {
        writer: ALLURE_TEST_MODE ? new MessageWriter() : new FileSystemWriter({
          resultsDir
        })
      }));
      this.testPath = context.testPath.replace(projectConfig.rootDir, "").replace(sep, "");
      this.testPlan = parseTestPlan();

      // @ts-ignore
      var testRuntime = new AllureJestTestRuntime(this, this.global);

      // @ts-ignore
      this.global.allure = allure;
      setGlobalTestRuntime(testRuntime);
    }
    setup() {
      return super.setup();
    }
    teardown() {
      return super.teardown();
    }
    handleAllureRuntimeMessage(message) {
      var executableUuid = last(this.runContext.executables);
      this.runtime.applyRuntimeMessages(executableUuid, [message]);
    }
  };
  function _getTestFullName(test) {
    var newTestSuitePath = getTestPath(test.parent);
    var newTestPath = newTestSuitePath.concat(test.name);
    var newTestId = getTestId(newTestPath);
    return "".concat(this.testPath, "#").concat(newTestId);
  }
  function _handleSuiteStart() {
    _assertClassBrand(_Class_brand, this, _startScope).call(this);
  }
  function _handleSuiteEnd() {
    _assertClassBrand(_Class_brand, this, _stopScope).call(this);
  }
  function _handleHookStart(hook) {
    if (shouldHookBeSkipped(hook)) {
      return;
    }
    var scopeUuid = last(this.runContext.scopes);
    var fixtureUuid = this.runtime.startFixture(scopeUuid, /after/i.test(hook.type) ? "after" : "before", {
      name: hook.type
    });
    this.runContext.executables.push(fixtureUuid);
  }
  function _handleHookPass(hook) {
    if (shouldHookBeSkipped(hook)) {
      return;
    }
    var fixtureUuid = this.runContext.executables.pop();
    this.runtime.updateFixture(fixtureUuid, r => {
      r.status = Status.PASSED;
      r.stage = Stage.FINISHED;
    });
    this.runtime.stopFixture(fixtureUuid);
  }
  function _handleHookFail(hook, error) {
    if (shouldHookBeSkipped(hook)) {
      return;
    }
    var fixtureUuid = this.runContext.executables.pop();
    var status = typeof error === "string" ? Status.BROKEN : getStatusFromError(error);
    this.runtime.updateFixture(fixtureUuid, r => {
      r.status = status;
      r.statusDetails = {
        message: typeof error === "string" ? error : error.message,
        trace: typeof error === "string" ? undefined : error.stack
      };
      r.stage = Stage.FINISHED;
    });
    this.runtime.stopFixture(fixtureUuid);
  }
  function _startTest(test) {
    var _test$startedAt;
    var newTestSuitePath = getTestPath(test.parent);
    var newTestFullName = _assertClassBrand(_Class_brand, this, _getTestFullName).call(this, test);
    if (this.testPlan && !isTestPresentInTestPlan(newTestFullName, this.testPlan)) {
      test.mode = "skip";
      this.runContext.skippedTestsFullNamesByTestPlan.push(newTestFullName);
      return;
    }
    var threadLabel = ALLURE_THREAD_NAME || JEST_WORKER_ID || process.pid.toString();
    var hostLabel = ALLURE_HOST_NAME || hostname;
    var packageLabel = dirname(this.testPath).split(sep).join(".");
    _assertClassBrand(_Class_brand, this, _startScope).call(this);
    var testUuid = this.runtime.startTest({
      name: test.name,
      fullName: newTestFullName,
      start: (_test$startedAt = test.startedAt) !== null && _test$startedAt !== void 0 ? _test$startedAt : undefined,
      labels: [{
        name: LabelName.LANGUAGE,
        value: "javascript"
      }, {
        name: LabelName.FRAMEWORK,
        value: "jest"
      }, {
        name: LabelName.PACKAGE,
        value: packageLabel
      }, ...getEnvironmentLabels()]
    }, this.runContext.scopes);
    this.runtime.updateTest(testUuid, result => {
      if (threadLabel) {
        result.labels.push({
          name: LabelName.THREAD,
          value: threadLabel
        });
      }
      if (hostLabel) {
        result.labels.push({
          name: LabelName.HOST,
          value: hostLabel
        });
      }
      result.labels.push(...getSuiteLabels(newTestSuitePath));
    });
    this.runContext.executables.push(testUuid);
    return testUuid;
  }
  function _stopTest(testUuid, duration) {
    if (!testUuid) {
      return;
    }
    this.runtime.stopTest(testUuid, {
      duration
    });
    this.runtime.writeTest(testUuid);
  }
  function _handleTestStart(test) {
    var testUuid = _assertClassBrand(_Class_brand, this, _startTest).call(this, test);
    if (!testUuid) {
      return;
    }
    this.runtime.updateTest(testUuid, result => {
      result.stage = Stage.RUNNING;
    });
  }
  function _handleTestDone() {
    _assertClassBrand(_Class_brand, this, _stopScope).call(this);
  }
  function _startScope() {
    var scopeUuid = this.runtime.startScope();
    this.runContext.scopes.push(scopeUuid);
  }
  function _stopScope() {
    var scopeUuid = this.runContext.scopes.pop();
    this.runtime.writeScope(scopeUuid);
  }
  function _handleTestPass(test) {
    var _test$duration;
    var testUuid = this.runContext.executables.pop();
    if (!testUuid) {
      return;
    }
    this.runtime.updateTest(testUuid, result => {
      result.stage = Stage.FINISHED;
      result.status = Status.PASSED;
    });
    _assertClassBrand(_Class_brand, this, _stopTest).call(this, testUuid, (_test$duration = test.duration) !== null && _test$duration !== void 0 ? _test$duration : 0);
  }
  function _handleTestFail(test) {
    var _test$duration2;
    var testUuid = this.runContext.executables.pop();
    if (!testUuid) {
      return;
    }

    // jest collects all errors, but we need to report the first one because it's a reason why the test has been failed
    var [error] = test.errors;
    var hasMultipleErrors = Array.isArray(error);
    var firstError = hasMultipleErrors ? error[0] : error;
    var details = getMessageAndTraceFromError(firstError);
    var status = getStatusFromError(firstError);
    this.runtime.updateTest(testUuid, result => {
      result.stage = Stage.FINISHED;
      result.status = status;
      result.statusDetails = _objectSpread({}, details);
    });
    _assertClassBrand(_Class_brand, this, _stopTest).call(this, testUuid, (_test$duration2 = test.duration) !== null && _test$duration2 !== void 0 ? _test$duration2 : 0);
  }
  function _handleTestSkip(test) {
    var _test$duration3;
    var newTestFullName = _assertClassBrand(_Class_brand, this, _getTestFullName).call(this, test);
    if (this.runContext.skippedTestsFullNamesByTestPlan.includes(newTestFullName)) {
      return;
    }
    var testUuid = this.runContext.executables.pop();
    if (!testUuid) {
      return;
    }
    this.runtime.updateTest(testUuid, result => {
      result.stage = Stage.PENDING;
      result.status = Status.SKIPPED;
    });
    _assertClassBrand(_Class_brand, this, _stopTest).call(this, testUuid, (_test$duration3 = test.duration) !== null && _test$duration3 !== void 0 ? _test$duration3 : 0);
  }
  function _handleTestTodo(test) {
    var _test$duration4;
    var testUuid = this.runContext.executables.pop();
    if (!testUuid) {
      return;
    }
    this.runtime.updateTest(testUuid, result => {
      result.stage = Stage.PENDING;
      result.status = Status.SKIPPED;
    });
    _assertClassBrand(_Class_brand, this, _stopTest).call(this, testUuid, (_test$duration4 = test.duration) !== null && _test$duration4 !== void 0 ? _test$duration4 : 0);
  }
  function _handleRunFinish() {
    this.runtime.writeEnvironmentInfo();
    this.runtime.writeCategoriesDefinitions();
  }
};
export default createJestEnvironment;
//# sourceMappingURL=environmentFactory.js.map